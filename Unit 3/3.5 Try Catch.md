# **Java Try-Catch Block ‚Äì Exception Handling**  

## **1Ô∏è‚É£ Introduction to Try-Catch Block**  
A **try-catch block** in Java is used for handling exceptions. It prevents abrupt termination of the program by **catching and handling runtime errors**.  

üìå **How It Works?**  
- The code that might throw an exception is placed inside the **try block**.  
- If an exception occurs, the program jumps to the **catch block** to handle the error.  
- The **finally block (if present)** executes after try-catch, whether an exception occurs or not.  

---

## **2Ô∏è‚É£ Example 1: Basic Try-Catch Block**  

```java
class TryCatchExample {
    public static void main(String[] args) {
        try {
            // This will throw an ArithmeticException (division by zero)
            int res = 10 / 0;
        } 
        catch (ArithmeticException e) {
            System.out.println("Exception caught: " + e);
        }

        // This line executes whether an exception occurs or not
        System.out.println("I will always execute");
    }
}
```
üñ• **Output:**  
```
Exception caught: java.lang.ArithmeticException: / by zero
I will always execute
```

---

## **3Ô∏è‚É£ Syntax of Try-Catch Block**  

```java
try {
    // Code that may throw an exception
} 
catch (ExceptionType e) {
    // Code to handle the exception
}
```

---

## **4Ô∏è‚É£ Understanding Try & Catch Blocks**  

### **üîπ Try Block**  
- The **try block** contains code that might throw an exception.  
- If an exception occurs, **remaining statements inside try are skipped**, and control transfers to the **catch block**.  

‚úî **Example:**  

```java
try {
    int num = 10 / 0;  // Division by zero causes an exception
    System.out.println("This line will not execute");
}
```

---

### **üîπ Catch Block**  
- The **catch block** handles exceptions that occur inside the try block.  
- It prevents the program from crashing and allows graceful error handling.  

‚úî **Example:**  

```java
try {
    int num = 10 / 0;
} 
catch (ArithmeticException e) {
    System.out.println("Exception caught: " + e);
}
```

üñ• **Output:**  
```
Exception caught: java.lang.ArithmeticException: / by zero
```

---

## **5Ô∏è‚É£ Internal Working of Try-Catch**  
1Ô∏è‚É£ **JVM starts executing the try block.**  
2Ô∏è‚É£ If an exception occurs, the remaining try block code is **skipped**.  
3Ô∏è‚É£ JVM looks for a **matching catch block**.  
4Ô∏è‚É£ If found, the catch block **executes** the error-handling code.  
5Ô∏è‚É£ If no catch block is found, the **JVM throws an error and terminates the program**.  
6Ô∏è‚É£ After handling, control moves to the **finally block (if present)**.  

‚úî **Example with Finally Block:**  

```java
try {
    int ans = 10 / 0;  // ArithmeticException
} 
catch (ArithmeticException e) {
    System.out.println("Caught ArithmeticException");
} 
finally {
    System.out.println("I will always execute whether an exception occurs or not");
}
```
üñ• **Output:**  
```
Caught ArithmeticException
I will always execute whether an exception occurs or not
```

---

## **6Ô∏è‚É£ Multiple Catch Blocks**  
A try block can have **multiple catch blocks** to handle different exception types.  

‚úî **Example:**  

```java
class MultipleCatchExample {
    public static void main(String[] args) {
        try {
            int res = 10 / 0;  // ArithmeticException
            String s = null;
            System.out.println(s.length());  // NullPointerException
        } 
        catch (ArithmeticException e) {
            System.out.println("Caught ArithmeticException: " + e);
        } 
        catch (NullPointerException e) {
            System.out.println("Caught NullPointerException: " + e);
        }
    }
}
```
üñ• **Output:**  
```
Caught ArithmeticException: java.lang.ArithmeticException: / by zero
```
‚û° The `NullPointerException` is **not executed** because once an exception is caught, the remaining try block code is skipped.

---

## **7Ô∏è‚É£ Nested Try-Catch Blocks**  
Java allows **nested try-catch blocks**, where one try-catch is placed inside another.  

‚úî **Example:**  

```java
public class NestedTryCatch {
    public static void main(String[] args) {
        try {
            System.out.println("Outer try block started");

            try {
                // Inner try block 1
                int res = 10 / 0;  // Throws ArithmeticException
            } 
            catch (ArithmeticException e) {
                System.out.println("Caught ArithmeticException in inner try-catch: " + e);
            }

            try {
                // Inner try block 2
                String s = null;
                System.out.println(s.length());  // Throws NullPointerException
            } 
            catch (NullPointerException e) {
                System.out.println("Caught NullPointerException in inner try-catch: " + e);
            }
        } 
        catch (Exception e) {
            System.out.println("Caught exception in outer try-catch: " + e);
        } 
        finally {
            System.out.println("Finally block executed");
        }
    }
}
```
üñ• **Output:**  
```
Outer try block started
Caught ArithmeticException in inner try-catch: java.lang.ArithmeticException: / by zero
Caught NullPointerException in inner try-catch: java.lang.NullPointerException
Finally block executed
```
‚úÖ **Advantages of Nested Try-Catch:**  
- It allows **better exception handling** by **separating different error types**.  
- If an exception occurs in one inner try block, it doesn‚Äôt affect others.  

---

## **8Ô∏è‚É£ Summary**  

üìå **Try-Catch Block in Java** ensures **smooth execution** even when exceptions occur.  
üìå **Try Block** contains code that **might throw an exception**.  
üìå **Catch Block** handles exceptions **gracefully**.  
üìå **Multiple Catch Blocks** handle different exception types separately.  
üìå **Finally Block** executes **whether an exception occurs or not**.  
üìå **Nested Try-Catch** allows handling **different exceptions separately** inside different try blocks.  

---

## **üîë Key Takeaways**  

‚úî **Try-Catch is essential** for handling exceptions and preventing program crashes.  
‚úî **Use Multiple Catch Blocks** for handling different exceptions efficiently.  
‚úî **Finally Block always executes**, making it useful for resource cleanup.  
‚úî **Nested Try-Catch** helps in **granular exception handling**.  
‚úî **Always handle exceptions properly** to ensure smooth program execution.  

