# **User-Defined Custom Exception in Java**

## **Introduction**
In Java, an **Exception** is an issue (runtime error) that occurs during program execution. When an exception occurs, the program terminates abruptly, and the code after the error is not executed.  

Java allows us to create our own exceptions, known as **custom exceptions** or **user-defined exceptions**. These exceptions are derived from the `Exception` class and help handle application-specific errors.  

### **Key Concepts:**
- Custom exceptions allow developers to define error scenarios relevant to their applications.
- They are thrown using the `throw` keyword.
- They can be either **checked** or **unchecked** exceptions.

---

## **Why Use Custom Exceptions?**
1. **Represent application-specific errors** – Helps categorize errors specific to business logic.  
2. **Enhance debugging** – Provides meaningful error messages.  
3. **Improve code clarity** – Encapsulates error handling in an organized manner.  

---

## **Creating a Custom Exception**
A custom exception is created by:
1. Extending the `Exception` class for **checked exceptions**.
2. Extending the `RuntimeException` class for **unchecked exceptions**.
3. Defining constructors to initialize the exception with messages.

### **Syntax of Custom Exception**
```java
class MyException extends Exception {
    public MyException(String message) {
        super(message);
    }
}
```

---

## **Example 1: Creating and Throwing a Custom Exception**
This example defines a **checked** custom exception named `MyException` and throws it inside a `try` block.

```java
// A Class that represents user-defined exception
class MyException extends Exception {
    public MyException(String m) {
        super(m);
    }
}

// A Class that uses the above MyException
public class CustomExceptionExample {
    public static void main(String args[]) {
        try {
            // Throw an object of user-defined exception
            throw new MyException("This is a custom exception");  
        }
        catch (MyException ex) {
            System.out.println("Caught");  // Catch and print message
            System.out.println(ex.getMessage());  
        }
    }
}
```

### **Output**
```
Caught
This is a custom exception
```

### **Explanation**
- The `MyException` class extends `Exception`, making it a checked exception.
- The `throw` keyword is used to throw the exception.
- The `catch` block catches and handles the exception.

---

## **Types of Custom Exceptions**
There are two types of custom exceptions:
1. **Checked Exceptions** – Must be declared in the method signature using `throws`.
2. **Unchecked Exceptions** – Do not require `throws` and extend `RuntimeException`.

---

## **Checked Custom Exception Example**
A checked custom exception must be handled using `throws` or `try-catch`.

```java
// Custom Checked Exception
class InvalidAgeException extends Exception {
    public InvalidAgeException(String m) {
        super(m);
    }
}

// Using the Custom Exception
public class CheckedExceptionExample {
    public static void validate(int age) throws InvalidAgeException {
        if (age < 18) {
            throw new InvalidAgeException("Age must be 18 or above.");
        }
        System.out.println("Valid age: " + age);
    }

    public static void main(String[] args) {
        try {
            validate(12);
        } catch (InvalidAgeException e) {
            System.out.println("Caught Exception: " + e.getMessage());
        }
    }
}
```

### **Output**
```
Caught Exception: Age must be 18 or above.
```

### **Explanation**
- The `InvalidAgeException` extends `Exception`, making it a checked exception.
- The `validate()` method throws `InvalidAgeException` when age is less than 18.
- The exception is caught and handled in `main()`.

---

## **Unchecked Custom Exception Example**
An unchecked exception does not require explicit handling.

```java
// Custom Unchecked Exception
class DivideByZeroException extends RuntimeException {
    public DivideByZeroException(String m) {
        super(m);
    } 
}

// Using the Custom Exception
public class UncheckedExceptionExample {
    public static void divide(int a, int b) {
        if (b == 0) {
            throw new DivideByZeroException("Division by zero is not allowed.");
        }
        System.out.println("Result: " + (a / b));
    }

    public static void main(String[] args) {
        try {
            divide(10, 0);
        } catch (DivideByZeroException e) {
            System.out.println("Caught Exception: " + e.getMessage());
        }
    }
}
```

### **Output**
```
Caught Exception: Division by zero is not allowed.
```

### **Explanation**
- The `DivideByZeroException` extends `RuntimeException`, making it an unchecked exception.
- The `divide()` method checks if the denominator is zero and throws an exception if true.
- The exception is caught in `main()`.

---

## **Key Differences Between Checked and Unchecked Exceptions**
| Feature            | Checked Exception                         | Unchecked Exception                     |
|--------------------|--------------------------------|--------------------------------|
| Extends           | `Exception`                    | `RuntimeException`            |
| Requires `throws` | Yes                            | No                             |
| Compile-time Check | Yes                            | No                             |
| Example           | `IOException`, `SQLException`  | `ArithmeticException`, `NullPointerException` |

---

## **Summary**
- **Custom Exceptions** allow defining meaningful exceptions for application-specific errors.
- They can be either **checked (extends Exception)** or **unchecked (extends RuntimeException)**.
- Use the `throw` keyword to explicitly throw an exception.
- Checked exceptions must be handled using `throws` or `try-catch`.
- Unchecked exceptions do not require handling but can be caught.

---

## **Points to Remember (For Exams)**
1. **Definition**: A user-defined custom exception is a class that extends `Exception` or `RuntimeException`.
2. **Checked vs. Unchecked Exceptions**: Checked exceptions require handling, whereas unchecked exceptions do not.
3. **Throwing a Custom Exception**: Use `throw new ExceptionName("message")` inside a method.
4. **Catching an Exception**: Use `try-catch` to handle exceptions.
5. **Handling Checked Exceptions**: Either use a `try-catch` block or declare them in the method signature using `throws`.
6. **Syntax for Custom Exception**:  
   ```java
   class MyException extends Exception {
       public MyException(String message) {
           super(message);
       }
   }
   ```
7. **Why Use Custom Exceptions?**  
   - Improves debugging  
   - Makes error messages more descriptive  
   - Helps in handling business logic errors properly  

